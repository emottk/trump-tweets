<!DOCTYPE html>
<html>
  <head>
    <title>Istrumpmad</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Changa:400,800" rel="stylesheet">

    <style>

      .bar{
        fill: steelblue;
      }

      .bar:hover{
        fill: brown;
      }

    	.axis {
    	  font: 10px sans-serif;
        fill: steelblue;
    	}

    	.axis path,
    	.axis line {
    	  stroke: #000;
    	  shape-rendering: auto;
    	}

    </style>
  </head>

  <body>

    <%= yield %>


    <script>

    // set the dimensions of the canvas
    var dim = {width: 960, height: 800};
    var margin = {top: 10, bottom: 50, left: 50, right: 10};
    var inputHeight = 20;
    var numberFormat = d3.format('.0f');
    dim.graphWidth = dim.width - margin.left - margin.right;
    dim.graphHeight = dim.height - margin.top - margin.bottom;

    // add the SVG element
    var svg = d3.select('div#howdy').append('svg')
      .attr({width: dim.width, height: dim.height})
      .style({margin:0,padding:0});

    // add axis
    var axisLayer = svg.append('g').attr('transform','translate(' + margin.left + ',' + margin.top + ')');
    var graphLayer = svg.append('g').attr('transform','translate(' + margin.left + ',' + margin.top + ')');
    var inputLayer = svg.append('g').attr('transform','translate(0,' + (dim.height - inputHeight) + ')');

    // set the ranges
    var xScale = d3.scale.ordinal().rangeBands([0,dim.graphWidth],0.05);
    var xLocalScale = d3.scale.ordinal();
    var yScale = d3.scale.ordinal().rangePoints([dim.graphHeight, 0]);
    var colorScale = d3.scale.category10();
    var inputScale = d3.scale.ordinal().rangeBands([0,dim.width-margin.right]);

    // define the axis
    var xAxis = d3.svg.axis().orient('bottom').scale(xScale);
    var yAxis = d3.svg.axis().orient('left').scale(yScale);

    //what is this axisLayer stuff?
    var xAxisObj = axisLayer.append('g')
      .attr('transform','translate('+0+','+dim.graphHeight+')')
      .attr('class','axis')
      .call(xAxis);
    var yAxisObj = axisLayer.append('g')
      .attr('transform','translate('+0 +','+0+')')
      .attr('class','axis')
      .call(yAxis)


    axisLayer.selectAll('.axis text').style('font','10px "Lucida Grande", Helvetica, Arial, sans-serif');
    axisLayer.selectAll('.axis path.domain').style({fill:'none',stroke:'#000000','shape-rendering':'auto'});
    axisLayer.selectAll('.axis line').style({fill:'none',stroke:'#000000','shape-rendering':'auto'});

    var time = 0;
    var yearLabel = 'year';
    var radius = 3.5;
    var mar = 0.6;
    var years = [];

    // load the data
    d3.json('circle.json', function(error,raw){
      if (error != null){
        console.log(error);
        return;
      }


      // structuring data
        // grab year values ie [0,1,2,3,4,5]
        // years = d3.set(raw.map(function(d){d[yearLabel];})).values();
        // raw.map(function(d){console.log(d[yearLabel]);})
        // console.log(years)
        // yearTarget = years[0];
        // grab letters ie [A,B,C,D,E]
        var weeks = d3.keys(raw[0]).filter(function(d){return d !== yearLabel;});
        var weeksDict = {};
        // iterate over x values to format an object. why?
        weeks.forEach(function(d,i){
          weeksDict[d] = i;
        });
        // console.log(weeksDict)
        // iterate over values to make data object with key of year and value of party
        // {0: Array(7), 1: Array(7), 2: Array(7), 3: Array(7), 4: Array(7), 5: Array(7)}
        // array has 7 data points for that year eg {0: [2,150,0,144,48,410,803]}
        // var sums = {};
        // var data = {};
        // years.forEach(function(year){
        //   data[year] = weeks.map(function(party){
        //     return +raw.filter( d => d[yearLabel] === year )
        //     party || 0;
        //
        //   });
        //   // add all the values by year
        //   // {0: 1557, 1: 1594, 2: 1584, 3: 1482, 4: 1627, 5: 1680}
        //   // sums[year] = d3.sum(data[year]);
        // });


        var data = {}
        var data_count = {}
        weeks.forEach(function(d,i){
          var negatives = []
          var all = raw[0][d][0]
          all.forEach(function(g){
            if (g['negative'] = 'true'){
              data_count[d] = negatives.push(g)
              data[d] = negatives

            }
          })

      })
      console.log(data)

        // setting domain
        // highest single data point ie 882
        var max = d3.max(Object.values(data_count));

        // console.log(years.map(function(d){console.log(data);}))
        // number of vertical rows/height of dots
        var nrow = 100//Math.ceil(dim.graphHeight/(2*(radius+mar)));
        // how wide should each bar be eg 15 dots
        barWidth = 1//Math.ceil(max/nrow);
        // set graph characteristics based on above
        yScale.domain(d3.range(nrow));
          //tick labels for y axis
        yAxis.tickValues(d3.range(nrow).filter(function(d){return d%10===0;}));
        yAxis.tickFormat(function(d){return (d*barWidth);});
        // domain([0,1,2,3,4,5,6] sets the 6 columns
        xScale.domain(weeks.map(function(d,i){return i;}));
        // display years "A" "B" "C"...
        xAxis.tickFormat(function(d){return weeks[d];});
          // not sure but if you remove you lose tickmarks and value of ticks
        xAxisObj.call(xAxis)
          .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", "-.55em")
            .attr("transform", "rotate(-90)" ); // turn the label on their side
        yAxisObj.call(yAxis).append('text').text("Tweets Per Week");


        xLocalScale.rangeBands([0,xScale.rangeBand()]).domain(d3.range(barWidth));
        colorScale.domain(d3.range(weeks.length));

        inputScale.domain(weeks);


      // var summax = d3.max(years.map(function(d){return sums[d];}));
      // this one looks pretty important
      var displaydata = d3.range(weeks.length).map(function(d){return [];});
      console.log(displaydata)
      var indexMargin = 0;
      // console.log("INDEZ")
      // console.log(indexMargin)
      weeks.forEach(function(d,index){
        console.log(index)
        // if (indexMargin+index<52){
        // console.log(d)
        // for (var i=0;i<weeks.length;++i){
        //   // console.log({label:d})
          console.log(indexMargin+index+1)
          // console.log((displaydata[indexMargin+index]))
          // if (indexMargin+index<51){

          displaydata[indexMargin+index].push({label:d,idx:index+1});

        // }
          // indexMargin += index;



      }
      );

      // console.log(displaydata)
      // for (var i=indexMargin;i<max;++i){
      //   displaydata[i].push({label:null,idx:null});
      // }
      //
      // console.log(displaydata)
      // circles added to the dom
      var negatives = graphLayer.selectAll('.negative').data(displaydata).enter().append('circle')
        .attr('class','negative')
        .attr('r',radius)
        .attr('cx',function(d){return ((d[label]!=null)?(xScale(d[label])+xLocalScale(d[idx]%barWidth)+radius+mar):(dim.graphWidth/2));})
        .attr('cy',function(d){return ((d[label]!=null)?(yScale(Math.floor((data[d[label]].length+0.1)/barWidth))-radius-mar):0);})
        .style('opacity',function(d){return (d[label]!=null)?0.8:0.0;})
        .style('fill','steelblue');  // black dots without this
        }); // end load the data

      // trying to make svg responsive
      // var aspect = dim.width / dim.height,
      // chart = d3.select('#chart');
      // d3.select(window)
      //   .on("resize", function() {
      //     var targetWidth = chart.node().getBoundingClientRect().width;
      //     chart.attr("width", targetWidth);
      //     chart.attr("height", targetWidth / aspect);
      // });

    </script>

  </body>
</html>
